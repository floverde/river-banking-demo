# River Banking Demo - Bank Service API

This is a demonstration project commissioned by River Tech Plc.

This project consists of a web service with a REST interface to manage banking operations.

1. Requirements
2. Database schema
3. REST endpoints
4. Class Diagram

### 1. Requirements
The application is a proof of concept aimed at creating bank accounts and transferring money between them.

Below is the full list of its features:

- Create a bank account by providing the holder's name and a 4-digit PIN.
  - The account number is automatically generated by the system.
  - A bank customer may hold multiple accounts.
- Once account is created one can *Deposit*, *Withdraw* or *Transfer* money between accounts.
  - Any operation which deducts funds from the account needs to include the correct PIN code.
  - A transaction history is kept for all balance changes.
- Provides a list of all bank accounts and transactions from them.
  - It is possible to get a list of all bank accounts.
  - By specifying the account number it is possible to access the transaction history of that account.

> **Note**: *the transaction history will also show any transfers received from other accounts.*

The development team was required to design the database and adhere to these technical specifications:

- All input information (which is not search filters) is provided as a JSON payload.
- Any unsuccessful operation should return appropriate error codes and messages.
- For demonstration purposes, use an in-memory database as a backing store.
- Use Kotlin as the programming language and Spring as the development framework.
- Include unit testing for your service layer.

Always for demonstration purposes, as a bonus not included in the initial requirements, were also integrated these two features:

- Account PINs are stored in hashed form (hashing algorithm chosen from configuration file).
- The output amounts are returned formatted with the system currency (also configurable).



### 2. Architectural Overview
Before describing how the REST interface works, it is useful to take a closer look at the application architecture.

From the application requirements we deduce that the main entities of the domain are **accounts** and banking **transactions**.

Bank *accounts* can be ***created*** and once created on them you can perform the following operations: ***withdrawals***, ***deposits*** and ***transfers***. Whenever an operation is successfully executed, a *transaction* is ***recorded***. It is possible to ***consult*** the list of *accounts*, and for each of them it is possible to ***consult*** the history of *transactions* made.

In a few lines we have highlighted the entities (`accounts` and `transactions`) and actions ( `created/recorder`, `withdrawal`, `deposit` and `transfer`, and `consultation` of accounts and transactions). At this point in the analysis, two possible implementation models are outlined: the *subordinate* model or the *peer* model. 

- The *subordinate* model sees the bank account as the only main actor (*resource*) and the transactions as a consequence of the actions on the bank account (thus modelled as a *sub-resource* associated with the bank account).
- In the *peer* model, on the other hand, accounts and transactions are modelled as two closely related resources at the same level. All operations resulting in the recording of a banking transaction will be interpreted as creation actions. For example, a withdrawal request from a bank account will be modelled as the creation of a transaction of type `withdrawal`, etc...

The differences between the two models are reflected in the way application functionality is exposed through the REST interface.

| Subordinate model (*account* > *transaction*)                | Peer model (account <-> transaction)     |
| ------------------------------------------------------------ | ---------------------------------------- |
| Transaction history of a certain account                     | Transaction history of a certain account |
| • `GET /accounts/{account-number}/transactions`              | • `GET /transactions?account={number}`   |
| Making a credit transfer                                     | Making a credit transfer                 |
| • `PATCH /accounts/{payer-number}/transfer-to/{payee-number}` | • `POST /transactions/transfer`          |
| Making a withdrawal                                          | Making a withdrawal                      |
| • `PATCH /accounts/{payer-number}/withdraw`                  | • `POST /transactions/withdraw`          |
| Making a deposit                                             | Making a deposit                         |
| • `PATCH /accounts/{payer-number}/deposit`                   | • `POST /transactions/deposit`           |
| Creating a new bank account (same)                           | Creating a new bank account (same)       |
| • `POST /accounts`                                           | • `POST /accounts`                       |

> **Note**: *the choice of one model or another only affects the REST layer, not the service layer.*

At the end, between the two models it was preferred to adopt the ***pair*** one, simply because it provides a cleaner interface and aggregates more information in the JSON payloads (as required by the specification).

### 2.1 Domain model

Now that the domain entities and the operations on them have been identified, we need to deal with how to actually model them within the application. Even in the peer model, the core entity of the domain remains the bank **accounts**. Each bank account is identified by its own account number which, according to the specifications, must be generated automatically. For simplicity of implementation, the `ID` field of its database table has been used as the account number. In addition to the unique ID, a bank account will be defined by the name of its `holder`, the current `balance`, and the 4-digit `pin` used to authenticate payment transactions.

> **Note**: *the `pin` field is binary because in the table it is not stored in plain text but using the hashed version.*

More complex is now the definition of the bank **transaction** record. At the relationship level, an account can carry out several operations which will be recorded as a time sequence of transactions. As a result, zero or more transactions may correspond to an account (*zero-to-many* relationship). Transactions originating from deposit and withdrawal operations are instead associated with one and only one account (*many-to-one* relationship), while wire transfers always involve two accounts: the *payer* and the *payee*. This would give rise to a *many-to-many* association which in relational databases is implemented through a third table (called a *relation table*). However, this would imply the need to use a JOIN between tables to retrieve the information of a transaction, and this is not the best from a performance point of view.

For this application, it was decided to dispense with the relation tables, keeping only the entity tables, and implementing a relation of the type: *many-to-one-or-two*. Within the transaction table, a reference to the `author` of the transaction is always maintained, while an optional reference to the beneficiary's account (called `target`) is only present in the case of transfers.

![erd-simple](C:\Users\fabri\Documents\GitHubProjects\river-banking-demo\doc\erd-simple.svg)

Together with the references to the accounts involved in the transaction, the value of the respective balances at the end of the transaction is also stored (`author_balance` and `target_balance` fields). Similar to accounts, transactions are also identified by a unique number, and as for them the `ID` field autogenerated by the database will be used. Besides that, a transaction is also characterized by its `amount` and execution `timestamp`.




![erd](C:\Users\fabri\Documents\GitHubProjects\river-banking-demo\doc\erd.png)

At first glance, it may appear that the transaction `type` has not been stored. How do we figure out if the operation that originated the transaction is a *transfer*, a *deposit* or a *withdrawal*? The following pseudo-code fragment explains how this information is inferred from the information we already have:

```pseudocode
/* Get the operation type of a transaction */
fun (transaction) -> operation.type {
	if (transaction has target) {
		return "transfer"
	} else {
		if (transaction.amount < 0) {
		    return "withdrawal"
        } else {
        	return "deposit"
        }
	}
}
```

Since, as previously mentioned, the reference to the `target` account is present only in case of a bank transfer, its presence or absence will indicate whether the transaction originated from a bank *transfer* or not. In addition, since the `amount` field is stored with the sign, this sign will provide an indication of whether the source transaction (in the case of a non-transfer transaction) is a *withdrawal* or a *deposit*.

Regarding transfers, they are also characterized by a `direction` (*incoming* or *outgoing*). The direction is not information that belongs to the transaction itself, but depends on the role played by a certain account. If an account is the *author* of a certain transfer, then we are in the presence of an `outgoing` transfer (a certain amount has been paid to another account). On the contrary, if the transaction passively involves the account (`target` reference), then the transfer is considered `incoming` (the account has collected a sum of money from another account).

```pseudocode
/* Gets the direction of a transfer where a certain account is involved */
fun (transfer, involved_account) -> transfer.direction {
	if (involved_account is transaction.author) {
		return "outgoing transfer"
	} else {
		return "incoming transfer"
	}
}
```

Putting it all together we get the following function:

```pseudocode
/* Gets the type of operation, and in case of transfer its direction from a certain transaction */
fun (transaction, involvedAccount) -> «operation.type, transfer.direction» {
	if (transaction has target) {
		if (involvedAccount is transaction.author) {
            return "outgoing transfer"
        } else {
            return "incoming transfer"
        }
	} else {
		if (transaction.amount < 0) {
		    return "withdrawal"
        } else {
        	return "deposit"
        }
	}
}
```

These considerations lead to a logical data model that is quite different from the physical model stored on the database.

![domain-model](C:\Users\fabri\Documents\GitHubProjects\river-banking-demo\doc\domain-model.svg)



### 2.2 Class diagram

Let's now take a bird's eye view of the architecture of the classes and components that build the application.

Like many other REST web services, this application follows the **MVC** (*Model-View-Controller*) pattern where the ***view layer*** is represented by the *REST interface* (blue package) while the ***model layer*** (green packages) is made of JPA repositories that interface to an *in-memory H2 database*.

The business logic (the *controller* part) resides mostly in the **service layer** (yellow packages) and part in the **mapping utilities** (red packages). The only piece of logic residing in the mapping utilities is solely the *inference function* of `operation.type` and `transfer.direction` shown in Section 2.1.

The *validation* of input data is instead divided between the REST interface layer and the service layer. Specifically, in the REST interface only primary validation is performed on the value of individual fields through validation annotations (**JSR 380** aka *Bean Validation* ).

More complex validations that go beyond the single field, and that involve more application logic, reside in the service layer. To be clear, checking that a certain field is not blank or that amounts are positive numeric values is handled through annotations. Also the check on the PIN format (which must be composed of 4 digits) is done through a validation annotation (since it is a check on the single field).

![class-diagram](C:\Users\fabri\Documents\GitHubProjects\river-banking-demo\doc\class-diagram.svg)

More complex controls such as verification of the existence of domain entities (accounts and transactions), authorization to make payments, etc... are instead the prerogative of the service layer. An example of control operated by the service layer is the check on the security PIN or the check on the sufficiency of funds to authorize a payment (be it a transfer or a withdrawal).

In the two purple packages are instead contained the exchange data structures respectively:

- between the service layer and the repositories (JPA Entities);
- between the service layer and the REST interface (DTO).

In the entity package, the `BankTransaction` and `Account` classes faithfully represent the database tables and their contents. For simplicity's sake we let Spring JPA create the definition of the tables on the database for us, starting from the Kotlin entity definition and JPA annotations. They therefore reflect the physical model described by the ER diagram shown at the beginning of section 2.1.

Instead, the classes in the DTO package reflect the logic model presented at the end of Section 2.1. These classes can be divided according to direction into *input DTOs* or *output DTOs*.

Among the input DTOs we find:

- `CreateAccountDTO`: parameters for creating a new account.
- `WithdrawalRequestDTO`: parameters to perform a withdrawal operation.
- `DepositRequestDTO`: parameters to perform a deposit operation.
- `TransferRequestDTO`: parameters for making a transfer.

Among the output DTOs we find:

- `TransactionHistoryDTO`: aggregates an account to its transaction history.
- `AccountDTO`: detailed view of account information.
- `AccountRefDTO`: summary view of account information.
- `TransactionResponseDTO`: output interface of a generic bank transaction.
  - `WithdrawalResponseDTO`: output structure of a withdrawal transaction.
  - `DepositResponseDTO`: output structure of a deposit transaction.
  - `TransferResponseDTO`: output interface of a bank transfer.
    - `IncomingTransferDTO`: output structure of an incoming transfer.
    - `OutgoingTransferDTO`: output structure of an outgoing transfer.



### 3. REST endpoints

Let's focus more on the most important part of the web service, which is its REST interface.

For each we will provide a full table of specifications, an explanation of the design, and provide an example of usage.

- Provide a list of all bank accounts
  - `HTTP GET /accounts`
- Creating a new bank account
  - `HTTP POST /accounts`
- Get the history of transactions involving a certain account
  - `HTTP GET /transactions?account={number}`
- Making a bank transfer
  - `HTTP POST /transactions/transfer`
- Making a bank withdrawal
  - `HTTP POST /transactions/withdraw`
- Making a bank transfer
  - `HTTP POST /transactions/deposit`

> **Note**: To test the service you can use any REST client, or alternatively, you can use the built-in automatically generated Swagger client. If the service is started in localhost, you can access the Swagger client at this address: http://localhost:8080/swagger-ui.html

### 3.1 "HTTP GET /accounts"

**Description**: Provide a list of all bank accounts.

| HTTP Verb | Path      |
| --------- | --------- |
| GET       | /accounts |

Since a search is a request for resources (where the resources are accounts), the use of **GET** and the path **/accounts** has been chosen. The endpoint takes no parameters and no payload and returns a collection of `AccountDTO` objects. 

**Output format** (class `AccountDTO`):

| Field   | Type   | Comments                 |
| ------- | ------ | ------------------------ |
| number  | long   | account unique number.   |
| holder  | string | account holder.          |
| balance | money  | current account balance. |

> **Note**: Since a bank customer can be a holder of multiple bank accounts, there was no need to map the `holder` entity, so it is only reported as a string field.

As mentioned at the end of section 1, a feature has been implemented that automatically formats the balance value of an account using the system currency. The type of currency used is configurable through a property in the configuration file:

```properties
mt.tech.river.bankingdemo.currency-code=EUR
```

The property is not mandatory, in fact if missing, the system currency will be used. The currency code must comply with the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) standard.

#### 3.1.1 Usage examples

Shows the list of all accounts registered in the bank.

**HTTP Request**:

```http
GET /accounts HTTP/1.1
```

**HTTP Response**:

```http
HTTP/1.1 200 OK
```
```json
[
  {
    "number": 1001,
    "holder": "Stanley Parker",
    "balance": "€ 500,00"
  },
  {
    "number": 1002,
    "holder": "Darren Atkinson",
    "balance": "€ 1000,00"
  },
  {
    "number": 1003,
    "holder": "Lizzie George",
    "balance": "€ 750,00"
  }
]
```



### 3.2 "HTTP POST /accounts"

**Description**: Creating a new bank account.

| HTTP Verb | Path      |
| --------- | --------- |
| POST      | /accounts |

Let's proceed now to open a new bank account. Since this is an operation of creation of a new resource (a *bank account*) we use **POST** as the HTTP verb. Even this endpoint does not take any parameters in the URL or query-string, but all the information is included in the JSON payload.

**Request payload** (class `CreateAccountDTO`):

| Field  | Type   | Comments                        |
| ------ | ------ | ------------------------------- |
| holder | string | holder of the new account       |
| pin    | string | security PIN (*4-digit format*) |

Both parameters are required to create an account. For the `holder` field the only requirement is that it is not blank, while for the `pin` field (as already mentioned above) it must be composed of only **4** numeric digits. Any violation of these specifications will result in the generation of an HTTP 400 error (indicating a malformed request).

If the creation is successful, a new account will be created whose number will be automatically assigned by the database (the corresponding `ID` field of the table). Of course, when an account is created, its `balance` is **zero**. Note that for security reasons, the account PIN is not shown.

**Possible HTTP response states**:

| HTTP Status     | Type    | Internal error | Comments                                             |
| --------------- | ------- | -------------- | ---------------------------------------------------- |
| 201 Created     | Success | --             | new account successfully created                     |
| 400 Bad Request | Error   | 0              | generic validation error (e.g: blank `holder` field) |
| 400 Bad Request | Error   | 2              | *null* or missing payload field                      |
| 400 Bad Request | Error   | 3              | malformed PIN                                        |

#### 3.2.1 Usage examples

Let's open a new bank account for John Smith, using `0000` as the security PIN.

**HTTP Request**:

```http
POST /accounts HTTP/1.1
Content-Type: application/json
```
```json
{
    "holder": "John Smith",
    "pin": "0000"
}
```

**HTTP Response**:

```http
HTTP/1.1 201 Created
```

```json
{
  "number": 1004,
  "holder": "John Smith",
  "balance": "€ 0,00"
}
```



### 3.3 "HTTP GET /transactions?account={number}"

**Description**: Shows the history of transactions in which a certain account has been involved.

| HTTP Verb | Path          |
| --------- | ------------- |
| GET       | /transactions |

Let's now examine the first of the endpoints that relate directly to `transactions`. It allows access to the transaction history of an account, or rather to all transactions involving a certain account. The history shows both transactions resulting from an operation carried out from that account and those in which the account is the recipient of an incoming transfer. 

| Query Param | Type | Required |
| ----------- | ---- | -------- |
| account     | long | yes      |

The account number is provided as a mandatory parameter in query-string (since it is a filter on `transaction` resource).

The history data structure includes both the detail of the account to which it relates (class `AccountDTO`), and lists all transactions associated with it. This list of transactions is already provided in temporal order from the most recent to the oldest. The items within the list are heterogeneous, but all of them implement the common data interface `TransactionResponseDTO`.

**Common fields of the transaction response DTO** (interface `TransactionResponseDTO`).

| Field          | Type      | Comments                                               |
| -------------- | --------- | ------------------------------------------------------ |
| transaction-id | long      | transaction unique ID.                                 |
| type           | enum      | transaction type {*Deposit*, *Transfer*, *Withdrawal*} |
| timestamp      | timestamp | transaction execution timestamp                        |
| amount         | money     | transaction amount.                                    |
| balance        | money     | account balance after completion of transaction.       |

Transactions triggered by the execution of a transfer (which implement the `TransferResponseDTO` data interface) include three additional fields: `direction`, `payer` (for incoming transfers) and `payee` for (for outcoming transfers).

**Specific fields for transfers response DTO** (interface `TransferResponseDTO` inherited from `TransactionResponseDTO`).

| Field     | Type        | Incoming | Outcoming | Comments                                          |
| --------- | ----------- | :------: | :-------: | ------------------------------------------------- |
| direction | enum        |    X     |     X     | transfer direction {*Incoming*, *Outgoing*}       |
| payer     | account-ref |    X     |           | payer account reference (only incoming transfers) |
| payee     | account-ref |          |     X     | payee account reference (only outgoing transfers) |

**Possible HTTP response states**:

| HTTP Status     | Type    | Internal error | Comments                                   |
| --------------- | ------- | -------------- | ------------------------------------------ |
| 200 OK          | Success | --             | transaction history returned successfully. |
| 400 Bad Request | Error   | 1              | missing `id` parameter                     |
| 404 Bad Request | Error   | 101            | `account` not found                        |

#### 3.3.1 Usage examples

Request for transaction history involving Stanley Parker's account (account number: `1001`).

**HTTP Request**:

```http
GET /transactions?account=1001 HTTP/1.1
Content-Type: application/json
```
**HTTP Response**:
```http
HTTP/1.1 200 OK
```
```json
{
    "account": {
        "number": 1001,
        "holder": "Stanley Parker",
        "balance": "€ 500,00"
    },
    "history": [
        {
            "transaction-id": 2003,
            "type": "Transfer",
            "direction": "Outgoing",
            "timestamp": "2021-03-24T13:32:26.876Z",
            "amount": "-€ 100,00",
            "balance": "€ 500,00",
            "payee": {
                "number": 1003,
                "holder": "Lizzie George"
            }
    	},
        {
            "transaction-id": 2002,
            "type": "Withdrawal",
            "timestamp": "2020-02-13T15:18:49.771Z",
            "amount": "-€ 450,00",
            "balance": "€ 600,00"
        },
        {
            "transaction-id": 2001,
            "type": "Deposit",
            "timestamp": "2020-01-05T09:11:11.907Z",
            "amount": "€ 1.050,00",
            "balance": "€ 1.050,00"
        }
    ]
}
```

Note that the last transaction (the first in the list) always corresponds to the value of the current account balance. Also note that transactions that decrease the account balance (whether they are *outgoing transfers* or *withdrawals*) always have a negative value in the `amount` field.

One last thought about the last transaction, number `2003`. In Staley's history it indicates that a transfer of €100 has been made to Lizzie, bringing the balance from €600 to €500 (*outgoing transfer*). The same transaction shown in Lizzie's history will instead show an incoming transfer of €100, which increased the balance from €0 to €100 (*incoming transfer*).

**HTTP Request**:

```http
GET /transactions?account=1003 HTTP/1.1
Content-Type: application/json
```
**HTTP Response**:
```http
HTTP/1.1 200 OK
```
```json
{
    "account": {
        "number": 1003,
        "holder": "Lizzie George",
        "balance": "€ 750,00"
    },
    "history": [
        // ....
        {
            "transaction-id": 2003,
            "type": "Transfer",
            "direction": "Incoming",
            "timestamp": "2021-03-24T13:32:26.876Z",
            "amount": "€ 100,00",
            "balance": "€ 100,00",
            "payer": {
                "number": 1001,
                "holder": "Stanley Parker"
            }
        }
    ]
}
```

If we forget to specify the account number parameter, we will get an HTTP 400 error having **1** (*missing parameter*) as the application error code.

**HTTP Request** *(missing `id` parameter)*:

```http
GET /transactions HTTP/1.1
Content-Type: application/json
```
**HTTP Response**:
```http
HTTP/1.1 400 Bad Request
```
```json
{
    "error": 1,
    "message": "Required request parameter 'account' for method parameter type long is not present"
}
```

Whereas if we instead requested a non-existing account (e.g. one with ID 9999), we would get a 404 HTTP error with the following error message.

**HTTP Request** *(account not found)*:

```http
GET /transactions?account=9999 HTTP/1.1
Content-Type: application/json
```
**HTTP Response**:

```http
HTTP/1.1 404 Not Found
```
```json
{
    "error": 101,
    "message": "Account with number 1 not found"
}
```



### 3.4 "HTTP POST /transactions/deposit"

**Description**: Make a deposit of money into the bank account.

| HTTP Verb | Path                  |
| --------- | --------------------- |
| POST      | /transactions/deposit |

Let us finally deal with the first of the three transactions that can be made using this application: ***bank deposits***. Since all banking transactions are interpreted by the application as the creation of a specific type of transaction, we will again use **POST** as the HTTP verb. As with the account creation endpoint, all banking endpoints do not take parameters from the URL or query-string, but they get all information from the JSON payload.

**Request payload** (class `DepositRequestDTO`):

| Field          | Type    | Comments                                            |
| -------------- | ------- | --------------------------------------------------- |
| account-number | long    | number of the account to which to make the deposit. |
| amount         | decimal | amount to be deposited into the account.            |

According to the bank's policy, any operation that increases the balance of a certain account does not require authorization. As a result, the only information required to make a deposit is the `account-number` to which the money is to be deposited and the actual `amount` to be deposited. For ease of implementation, all input amounts in JSON payloads are provided as a simple decimal number (not in monetary format, as is the case with output values).

**Possible HTTP response states**:

| HTTP Status     | Type    | Internal error | Comments                                             |
| --------------- | ------- | -------------- | ---------------------------------------------------- |
| 201 Created     | Success | --             | deposit successfully made.                           |
| 400 Bad Request | Error   | 0              | generic validation error (e.g: *wrong field format*) |
| 400 Bad Request | Error   | 2              | *null* or missing payload field                      |
| 404 Bad Request | Error   | 101            | `account` not found                                  |

If the operation completes successfully, an object describing the deposit transaction just performed is returned. Its data structure is the one already described in section 3.3, that is the `TransactionResponseDTO` interface.

#### 3.4.1 Usage examples

Let's make the first deposit into the account that John Smith has recently opened (account number `1004`).

**HTTP Request**:

```http
POST /transactions/deposit HTTP/1.1
Content-Type: application/json
```

```json
{
    "account-number": 1004,
    "amount": 350.0
}
```

**HTTP Response**:

```http
HTTP/1.1 201 Created
```

```json
{
    "transaction-id": 2007,
    "type": "Deposit",
    "timestamp": "2021-05-08T18:06:12.280Z",
    "amount": "€ 350,00",
    "balance": "€ 350,00"
}
```

Since this is the first transaction involving John's account, the `balance` value will be equal to the `amount` of this deposit.



### 3.5 "HTTP POST /transactions/withdraw"

**Description**: Make a withdrawal from the bank account

| HTTP Verb | Path                   |
| --------- | ---------------------- |
| POST      | /transactions/withdraw |

Let's examine the withdrawal transaction, also modelled as creating a withdrawal transaction (HTTP verb: **POST**).

The interface and interaction mode are similar to the deposit operation, except for the presence of the `pin` field among the request parameters. It is necessary because it is an operation of reduction of the funds in the account, and as such must be protected by the use of the security PIN.

Moreover, since the bank does not allow an account to go overdrawn, it is necessary that the amount to be withdrawn is in the account at the time of withdrawal.

**Possible HTTP response states**:

| HTTP Status     | Type    | Internal error | Comments                                             |
| --------------- | ------- | -------------- | ---------------------------------------------------- |
| 201 Created     | Success | --             | withdrawal successfully made.                        |
| 400 Bad Request | Error   | 0              | generic validation error (e.g: *wrong field format*) |
| 400 Bad Request | Error   | 2              | *null* or missing payload field                      |
| 400 Bad Request | Error   | 4              | wrong `pin` provided                                 |
| 404 Not  Found  | Error   | 101            | `account` not found                                  |
| 409 Conflict    | Error   | 201            | insufficient funds on the account                    |

#### 3.5.1 Usage examples

Let's make a withdrawal of €75 from John Smith's account (account number `1004`).

**HTTP Request**:

```http
POST /transactions/withdraw HTTP/1.1
Content-Type: application/json
```

```json
{
    "account-number": 1004,
    "amount": 75.0,
    "pin": "0000"
}
```

**HTTP Response**:

```http
HTTP/1.1 201 Created
```

```json
{
    "transaction-id": 2008,
    "type": "Withdrawal",
    "timestamp": "2021-05-08T18:24:49.351Z",
    "amount": "-€ 75,00",
    "balance": "€ 275,00"
}
```

Note that the funds in John's account that were previously 350€ have correctly become 275€ as a result of this operation.

However, it can happen that an incorrect pin is accidentally entered, or that someone else is attempting to fraudulently withdraw cash from John's account. In these cases, if the security PIN provided is incorrect, the operation will be blocked and the following error will be displayed instead:

**HTTP Response** (*case: wrong pin*):

```http
HTTP/1.1 400 Bad Request
```

```json
{
    "error": 4,
    "message": "The pin provided for account number 1004 is wrong (provided: \"1000\")"
}
```

Let's assume now that John wants to withdraw 500€ from his account by mistake, while in reality he has only 350€.

In this case the funds will not be sufficient to cover the operation and this error message will be displayed.

**HTTP Response** (*case: insufficient funds*):

```http
HTTP/1.1 409 Conflit
```

```json
{
    "error": 201,
    "message": "Account number 1004 does not have enough money to complete the transaction (required: € 500,00 | available € 350,00)."
}
```



### 3.6 "HTTP POST /transactions/transfer"

**Description**: Executes a bank transfer from one account to another.

| HTTP Verb | Path                   |
| --------- | ---------------------- |
| POST      | /transactions/transfer |

Finally we look at the most complex operation of the whole application, that is the execution of a bank **transfer**. Here the operating parameters change slightly since we no longer just deal with one generic account, but with two. Specifically, the two accounts play a different role, one will be the ***payer*** (i.e. the one who makes the transfer), while the other will be the ***payee*** (i.e. the one who collects the transfer). Furthermore, since this is also an operation that (on the payer side) decreases the balance of an account, it will be necessary to provide the security `pin`. 

**Request payload** (class `TransferRequestDTO`):

| Field        | Type    | Comments                                      |
| ------------ | ------- | --------------------------------------------- |
| payer-number | long    | number of the account making the transfer     |
| payee-number | long    | number of the account receiving the transfer. |
| amount       | decimal | transfer amount.                              |
| pin          | string  | payer account security PIN (*4-digit format*) |

If we correctly fill in the fields of the request and the transaction is successful, we will see in output a data structure that summarizes the information related to the user transfer just made. The output format is the one described by class `OutgoingTransferDTO` which inherits from the data interfaces `TransactionResponseDTO > TransferResponseDTO`, specifying a fixed `direction` (*outgoing*) and a reference to the `payee` account.

**Output format** (class `OutgoingTransferDTO` inherited from `TransactionResponseDTO > TransferResponseDTO`):

| Field          | Type        | Comments                                                     |
| -------------- | ----------- | ------------------------------------------------------------ |
| transaction-id | long        | transaction unique ID                                        |
| type           | enum        | *[constant]* always: `Transfer`                              |
| direction      | enum        | *[constant]* always: `Outgoing`                              |
| timestamp      | timestamp   | transfer execution timestamp                                 |
| amount         | money       | transfer amount (negative value)                             |
| balance        | money       | balance of the payer's account upon completion of the transfer |
| payee          | account-ref | reference to the payee's account (`id` and `holder` fields)  |

Like the withdrawal operation, the transfer will also require validation of the PIN of the account making the transfer (*payer-account*). It will also be checked that there are sufficient funds in the payer's account to actually make the transfer. In order to prevent the execution of circular transfers, it will also be checked that the payer and payee account doesn't match (*loopback-transfer* avoidance).

**Possible HTTP response states**:

| HTTP Status     | Type    | Internal error | Comments                                                     |
| --------------- | ------- | -------------- | ------------------------------------------------------------ |
| 201 Created     | Success | --             | withdrawal successfully made.                                |
| 400 Bad Request | Error   | 0              | generic validation error (e.g: *wrong field format*)         |
| 400 Bad Request | Error   | 2              | *null* or missing payload field                              |
| 400 Bad Request | Error   | 4              | wrong `pin` provided                                         |
| 400 Bad Request | Error   | 5              | loopback-transfer (`payer` and `payee` accounts are the same) |
| 404 Not Found   | Error   | 102            | `payer`'s account not found                                  |
| 404 Not Found   | Error   | 103            | `payee`'s account not found                                  |
| 409 Conflict    | Error   | 201            | insufficient funds on the account                            |

In the case of transfers, the not found errors were specialized to provide an indication as to which of the two accounts is not found. Note that the existence of the payer's account is always checked first, and only after that of the payee, so if both are non-existent, only the payer will be reported as missing.

#### 3.6.1 Usage examples

Let's imagine that John (*account-number:* `1004`) wants to make a transfer to Lizzie (*account-number:* `1003`) of **10,25€**.

**HTTP Request**:

```http
POST /transactions/transfer HTTP/1.1
Content-Type: application/json
```

```json
{
    "payer-number": 1004,
    "payee-number": 1003,
    "amount": 10.25,
    "pin": "0000"
}
```

**HTTP Response**:

```http
HTTP/1.1 201 Created
```

```json
{
    "transaction-id": 2009,
    "type": "Transfer",
    "direction": "Outgoing",
    "timestamp": "2021-05-09T08:03:11.518Z",
    "amount": "-€ 10,25",
    "balance": "€ 264,75",
    "payee": {
        "number": 1003,
        "holder": "Lizzie George"
    }
}
```

For example, if John tried to make a transfer to his own account (`payer-number == payee-number`), he would get this error:

**HTTP Response** (case: *loopback-transfer*):

```http
HTTP/1.1 400 Bad Request
```

```json
{
  "error": 5,
  "message": "Invalid transaction: unable to perform a transfer to the same account (number: 1004)."
}
```

> **Note**: it's always possible for John to make a transfer to another account in his name, since the check is on the holders but on the accounts.

However, if John wanted to make a transfer that exceeded his account balance, he would get this error:

**HTTP Response** (case: *insufficient funds*):

```http
HTTP/1.1 409 Conflict
```

```json
{
  "error": 201,
  "message": "Account number 1004 does not have enough money to complete the transaction (required: € 100.000,00 | available € 264,75)."
}
```

Let's imagine instead that the bank operator makes a mistake in typing John's account number and enters `9999` (non-existent account) instead. The system would then generate such an error:

**HTTP Response** (case: *payer not found*):

```http
HTTP/1.1 404 Not Found
```

```json
{
  "error": 102,
  "message": "Payer account with number 9999 not found"
}
```

Same thing in the case of Lizzie's account, which is the beneficiary's account:

**HTTP Response** (case: *payee not found*):

```http
HTTP/1.1 404 Not Found
```

```json
{
  "error": 103,
  "message": "Payee account with number 9999 not found"
}
```

Going back to the success case, we can further check the success of the operation from John and Lizzie's transaction history.

**HTTP Request** (*checking the transaction history of John's account*):

```http
GET /transactions?account=1004 HTTP/1.1
Content-Type: application/json
```

**HTTP Response**:

```http
HTTP/1.1 200 OK
```

```json
{
    "account": {
        "number": 1004,
        "holder": "John Smith",
        "balance": "€ 264,75"
    },
    "history": [
        {
    		"transaction-id": 2009,
    		"type": "Transfer",
    		"direction": "Outgoing",
    		"timestamp": "2021-05-09T08:03:11.518Z",
    		"amount": "-€ 10,25",
    		"balance": "€ 264,75",
    		"payee": {
        		"number": 1003,
        		"holder": "Lizzie George"
    		}
		},
        // ...
    ]
}
```

The same transaction (id: `2009`) on Lizzie's account history will be visible as an incoming transfer:

**HTTP Request** (*checking the transaction history of Lizzie's account*):

```http
GET /transactions?account=1003 HTTP/1.1
Content-Type: application/json
```

**HTTP Response**:

```http
HTTP/1.1 200 OK
```

```json
{
    "account": {
        "number": 1003,
        "holder": "Lizzie George",
        "balance": "€ 760,25"
    },
    "history": [
        {
    		"transaction-id": 2009,
    		"type": "Transfer",
    		"direction": "Incoming",
    		"timestamp": "2021-05-09T08:03:11.518Z",
    		"amount": "€ 10,25",
    		"balance": "€ 760,25",
    		"payer": {
        		"number": 1004,
        		"holder": "John Smith"
    		}
		},
        // ...
    ]
}
```

----

_Author: Fabrizio Lo Verde_